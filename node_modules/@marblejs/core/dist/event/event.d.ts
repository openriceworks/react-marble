import * as t from 'io-ts';
import { EventWithPayload, EventWithoutPayload } from './event.interface';
declare type Payload = t.TypeC<any> | t.TupleC<any> | t.UnionC<any> | t.ReadonlyC<any> | t.ReadonlyArrayC<any> | t.UnknownC | t.ArrayC<any> | t.StringC | t.BigIntC | t.BooleanC | t.BrandC<any, any> | t.NumberC | t.NullC | t.UnionC<any> | t.UndefinedC | t.PartialC<any> | t.BrandC<any, any> | t.RecordC<any, any> | t.IntersectionC<any> | t.ExactC<any> | t.UnknownRecordC | t.StringC | t.LiteralC<any> | t.KeyofC<any>;
export declare type EventCodec = EventSchemaWithPayload<any, any> | EventSchema<any>;
export declare type EventSchema<T extends string> = t.TypeC<{
    type: t.LiteralC<T>;
    payload: t.UndefinedC;
}>;
export declare type EventSchemaWithPayload<T extends string, P extends Payload> = t.TypeC<{
    type: t.LiteralC<T>;
    payload: P;
}>;
declare type EventCreator<T extends string> = () => EventWithoutPayload<T>;
declare type EventCreatorWithPayload<T extends string, P extends Payload> = (payload: t.TypeOf<P>) => EventWithPayload<t.TypeOf<P>, T>;
declare type EventBuilderOutput<T extends string, P extends Payload | undefined> = undefined extends P ? EventSchema<T> & {
    create: EventCreator<T>;
} : EventSchemaWithPayload<T, NonNullable<P>> & {
    create: EventCreatorWithPayload<T, NonNullable<P>>;
};
export declare const EVENT_CODEC_NAME = "EventSchema";
export declare const isEventCodec: (codec: any) => codec is EventCodec;
/**
 * Creates an Event codec for decoding and creating I/O events.
 * @since v3.3.0
 * @example
 *
 * const CreateUser = event('CREATE_USER')(t.type({
 *   name: t.string,
 *   age: t.number,
 * }));
 *
 * CreateUser.create({
 *   name: 'Bob',
 *   age: 21,
 * });
 */
export declare const event: <T extends string>(type: T) => <P extends Payload | undefined>(payload?: P | undefined) => EventBuilderOutput<T, P>;
export {};
//# sourceMappingURL=event.d.ts.map