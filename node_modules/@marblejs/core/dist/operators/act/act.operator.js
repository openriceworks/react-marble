"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.act = void 0;
const O = require("fp-ts/lib/Option");
const pipeable_1 = require("fp-ts/lib/pipeable");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const utils_1 = require("../../+internal/utils");
function act(callFn, errorFn) {
    const DEFAULT_ERROR_SUFFIX = '_UNHANDLED_ERROR';
    const getDefaultErrorEvent = (error) => (event) => {
        var _a;
        return (0, rxjs_1.of)({
            type: !event.type.includes(DEFAULT_ERROR_SUFFIX)
                ? event.type + DEFAULT_ERROR_SUFFIX
                : event.type,
            error: (_a = (0, utils_1.encodeError)(error)) !== null && _a !== void 0 ? _a : true,
            metadata: event.metadata,
        });
    };
    const handleError = (event) => (error) => (0, pipeable_1.pipe)(O.fromNullable(errorFn), O.map(fn => fn(error, event)), O.map(res => !(0, rxjs_1.isObservable)(res) ? (0, rxjs_1.of)(res) : res), O.map(res => res.pipe((0, operators_1.map)(r => { var _a; return (Object.assign(Object.assign({}, r), { error: (_a = r.error) !== null && _a !== void 0 ? _a : true })); }))), O.getOrElse(() => getDefaultErrorEvent(error)(event)));
    return (source) => source.pipe((0, operators_1.mergeMap)(event => (0, rxjs_1.defer)(() => {
        try {
            return event.error
                ? handleError(event)(event.error)
                : (0, pipeable_1.pipe)(callFn(event), (0, operators_1.catchError)(handleError(event)));
        }
        catch (error) {
            return handleError(event)(error);
        }
    })));
}
exports.act = act;
