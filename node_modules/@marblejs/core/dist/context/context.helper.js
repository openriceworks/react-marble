"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.contextFactory = exports.constructContext = void 0;
const T = require("fp-ts/lib/Task");
const O = require("fp-ts/lib/Option");
const IO = require("fp-ts/lib/IO");
const pipeable_1 = require("fp-ts/lib/pipeable");
const function_1 = require("fp-ts/lib/function");
const logger_1 = require("../logger");
const utils_1 = require("../+internal/utils");
const context_1 = require("./context");
/**
 * `INTERNAL` - unregisters redundant token if available in DerivedContext
 * @since v3.4.0
 */
const unregisterRedundantToken = (token) => (context) => {
    const deleteToken = (0, pipeable_1.pipe)(() => context.delete(token), IO.map((0, function_1.constant)(context)));
    return (0, pipeable_1.pipe)((0, context_1.lookup)(context)(context_1.DerivedContextToken), O.chain(derivedContext => (0, context_1.lookup)(derivedContext)(token)), O.fold(() => IO.of(context), () => deleteToken));
};
/**
 * Constructs and resolves a new or derived context based on provided dependencies
 * @since v3.4.0
 */
const constructContext = (context) => (...dependencies) => (0, pipeable_1.pipe)(context !== null && context !== void 0 ? context : (0, context_1.createContext)(), (0, context_1.registerAll)([
    (0, context_1.bindTo)(logger_1.LoggerToken)((0, utils_1.isTestEnv)() ? logger_1.mockLogger : logger_1.logger),
    ...dependencies,
]), context => () => (0, context_1.resolve)(context), T.chain(context => T.fromIO(unregisterRedundantToken(logger_1.LoggerToken)(context))))();
exports.constructContext = constructContext;
/**
 * Constructs and resolves a new context based on provided dependencies
 * @since v3.2.0
 */
exports.contextFactory = (0, exports.constructContext)();
