"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveRouting = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const function_1 = require("fp-ts/lib/function");
const O = require("fp-ts/lib/Option");
const core_1 = require("@marblejs/core");
const utils_1 = require("@marblejs/core/dist/+internal/utils");
const http_interface_1 = require("../http.interface");
const http_error_effect_1 = require("../error/http.error.effect");
const http_error_model_1 = require("../error/http.error.model");
const httpRequestBus_reader_1 = require("../server/internal-dependencies/httpRequestBus.reader");
const httpRequestMetadataStorage_reader_1 = require("../server/internal-dependencies/httpRequestMetadataStorage.reader");
const http_router_query_factory_1 = require("./http.router.query.factory");
const http_router_matcher_1 = require("./http.router.matcher");
const http_router_effects_1 = require("./http.router.effects");
const http_router_helpers_1 = require("./http.router.helpers");
const http_router_combiner_1 = require("./http.router.combiner");
const resolveRouting = (config) => {
    const requestBus = (0, core_1.useContext)(httpRequestBus_reader_1.HttpRequestBusToken)(config.ctx.ask);
    const logger = (0, core_1.useContext)(core_1.LoggerToken)(config.ctx.ask);
    const outputSubject = new rxjs_1.Subject();
    const errorSubject = new rxjs_1.Subject();
    const requestMetadataStorage = config.ctx.ask(httpRequestMetadataStorage_reader_1.HttpRequestMetadataStorageToken);
    /**
     * Server close stream (closes all active streams)
     */
    const close$ = (0, function_1.pipe)((0, rxjs_1.fromEvent)(config.ctx.client, 'close'), (0, operators_1.take)(1), (0, operators_1.share)());
    /**
     * Outgoing response stream (the result triggers HTTP response call)
     */
    const response$ = (0, function_1.pipe)(outputSubject.asObservable(), o$ => config.output$ ? config.output$(o$, config.ctx) : o$, (0, operators_1.takeUntil)(close$));
    /**
     * Outgoing error response stream (the result triggers HTTP response call)
     */
    const error$ = (0, function_1.pipe)(errorSubject.asObservable(), (0, operators_1.map)(({ request, error }) => (0, http_error_model_1.isHttpRequestError)(error) ? { request, error: error.error } : ({ request, error })), e$ => config.error$ ? config.error$(e$, config.ctx) : (0, http_error_effect_1.defaultError$)(e$, config.ctx), (0, operators_1.takeUntil)(close$));
    /**
     * Subscribe to all outgoing HTTP responses and trigger side effect
     * @param stream$ incoming `HttpEffectResponse`
     * @returns `Subscription`
     */
    const subscribeResponse = (stream$) => stream$
        .pipe((0, operators_1.tap)(output => (0, function_1.pipe)(requestMetadataStorage, O.fold(function_1.constVoid, metadataStorage => metadataStorage.collect(output)))), (0, operators_1.mergeMap)((_a) => {
        var { request } = _a, res = __rest(_a, ["request"]);
        return request.response.send(res);
    }))
        .subscribe({
        error: (0, function_1.flow)(http_error_model_1.unexpectedErrorWhileSendingResponseFactory, utils_1.throwException),
    });
    subscribeResponse(response$);
    subscribeResponse(error$);
    const bootstrappedRrouting = config.routing.map(item => (Object.assign(Object.assign({}, item), { methods: Object.entries(item.methods).reduce((acc, [method, methodItem]) => {
            if (!methodItem)
                return { [method]: undefined };
            const { middlewares, effect, parameters, meta } = methodItem;
            const subject = new rxjs_1.Subject();
            const decorate = !(meta === null || meta === void 0 ? void 0 : meta.continuous);
            const middleware = (0, http_router_combiner_1.combineRouteMiddlewares)(decorate, errorSubject)(...middlewares);
            logger({
                tag: "http" /* HTTP */,
                type: 'Router',
                message: `Effect mapped: ${item.path || '/'} ${method}`,
            })();
            const processError = (error, originStream$) => {
                if (!error.request)
                    throw (0, http_error_model_1.errorNotBoundToRequestErrorFactory)(error);
                errorSubject.next({ error, request: error.request });
                return originStream$;
            };
            const output$ = (0, function_1.pipe)(subject.asObservable(), e$ => middleware(e$, config.ctx), e$ => decorate ? (0, http_router_helpers_1.decorateEffect)(e$, errorSubject) : e$, e$ => effect(e$, config.ctx), (0, operators_1.catchError)(processError), (0, operators_1.takeUntil)(close$));
            const subscribe = (stream$) => stream$.subscribe({
                next: res => {
                    if (!res.request)
                        throw (0, http_error_model_1.responseNotBoundToRequestErrorFactory)(res);
                    outputSubject.next(Object.assign(Object.assign({}, res), { request: res.request }));
                },
                error: err => {
                    const type = 'RouterResolver';
                    const message = `Unexpected error for Output stream: "${err.name}", "${err.message}"`;
                    logger({ tag: "http" /* HTTP */, type, message, level: core_1.LoggerLevel.ERROR })();
                },
                complete: () => {
                    const type = 'RouterResolver';
                    const message = `Effect stream completes`;
                    logger({ tag: "http" /* HTTP */, type, message, level: core_1.LoggerLevel.DEBUG })();
                },
            });
            subscribe(output$);
            return Object.assign(Object.assign({}, acc), { [method]: { subject, parameters } });
        }, {}) })));
    const find = (0, http_router_matcher_1.matchRoute)(bootstrappedRrouting);
    /**
     * Resolve incoming request
     * @param request `HttpRequest`
     * @returns `void`
     */
    const resolve = (request) => {
        const [urlPath, urlQuery] = request.url.split('?');
        try {
            const resolvedRoute = find(urlPath, request.method);
            if (!resolvedRoute) {
                return errorSubject.next({ request, error: http_router_effects_1.ROUTE_NOT_FOUND_ERROR });
            }
            request.query = (0, http_router_query_factory_1.queryParamsFactory)(urlQuery);
            request.params = resolvedRoute.params;
            request.meta = {};
            request.meta.path = resolvedRoute.path;
            resolvedRoute.subject.next(request);
            requestBus.next(request);
        }
        catch (error) {
            let httpError;
            if ((0, http_error_model_1.isURIError)(error))
                httpError = new http_error_model_1.HttpError(error.message, http_interface_1.HttpStatus.BAD_REQUEST);
            else
                httpError = new http_error_model_1.HttpError(`Internal server error: ${(0, utils_1.getErrorMessage)(error)}`, http_interface_1.HttpStatus.INTERNAL_SERVER_ERROR);
            errorSubject.next({ request, error: httpError });
        }
    };
    return {
        resolve,
        errorSubject,
        outputSubject,
        response$: (0, rxjs_1.merge)(response$, error$),
    };
};
exports.resolveRouting = resolveRouting;
