import { Subject } from 'rxjs';
import { HttpMethod, HttpRequest, WithHttpRequest } from '../http.interface';
import { HttpEffect, HttpMiddlewareEffect, HttpEffectResponse } from '../effects/http.effects.interface';
export declare type ErrorSubject = Subject<WithHttpRequest<{
    error: Error;
}>>;
export interface RouteMeta extends Record<string, any> {
    name?: string;
    continuous?: boolean;
    overridable?: boolean;
}
export interface RouteEffect<T extends HttpRequest = HttpRequest> {
    path: string;
    method: HttpMethod;
    effect: HttpEffect<T, HttpEffectResponse>;
    middleware?: HttpMiddlewareEffect;
    meta?: RouteMeta;
}
export interface RouteEffectGroup {
    path: string;
    middlewares: HttpMiddlewareEffect[];
    effects: (RouteEffect | RouteEffectGroup)[];
}
export interface RouteCombinerConfig {
    middlewares?: HttpMiddlewareEffect[];
    effects: (RouteEffect | RouteEffectGroup)[];
}
export interface ParametricRegExp {
    regExp: RegExp;
    parameters?: string[] | undefined;
    path: string;
}
export interface RoutingMethod {
    parameters?: string[];
    middlewares: HttpMiddlewareEffect[];
    effect: HttpEffect;
    meta?: RouteMeta;
}
export interface RoutingItem {
    regExp: RegExp;
    path: string;
    methods: Partial<Record<HttpMethod, RoutingMethod>>;
}
export declare type Routing = RoutingItem[];
export interface BootstrappedRoutingItem extends Omit<RoutingItem, 'methods'> {
    methods: Partial<Record<HttpMethod, {
        subject: Subject<HttpRequest>;
        parameters?: string[];
    }>>;
}
export declare type BootstrappedRouting = BootstrappedRoutingItem[];
export interface RouteMatched {
    subject: Subject<HttpRequest>;
    params: Record<string, string>;
    path: string;
}
//# sourceMappingURL=http.router.interface.d.ts.map