"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.factorizeRoutingWithDefaults = exports.factorizeRouting = void 0;
const core_1 = require("@marblejs/core");
const utils_1 = require("@marblejs/core/dist/+internal/utils");
const http_router_helpers_1 = require("./http.router.helpers");
const http_router_params_factory_1 = require("./http.router.params.factory");
const http_router_effects_1 = require("./http.router.effects");
const canOverrideRoute = (route) => { var _a; return ((_a = route.meta) === null || _a === void 0 ? void 0 : _a.overridable) === true; };
const factorizeRouting = (routes, middlewares = [], parentPath = '') => {
    const routing = [];
    routes.forEach(route => {
        const concatenatedPath = parentPath + '/' + route.path;
        if ((0, http_router_helpers_1.isRouteEffectGroup)(route)) {
            return routing.push(...(0, exports.factorizeRouting)(route.effects, [...middlewares, ...route.middlewares], concatenatedPath));
        }
        const { regExp, parameters, path } = (0, http_router_params_factory_1.factorizeRegExpWithParams)(concatenatedPath);
        const foundRoute = routing.find(route => route.regExp.source === regExp.source);
        const method = {
            parameters,
            effect: route.effect,
            meta: route.meta,
            middlewares: [
                ...middlewares,
                ...(0, utils_1.insertIf)(!!route.middleware)(route.middleware),
            ],
        };
        if (foundRoute) {
            if (!canOverrideRoute(route) && foundRoute.methods[route.method]) {
                const routePath = (parentPath + route.path).replace(/\/\//g, '/');
                throw (0, core_1.coreErrorFactory)(`Redefinition of route at "${route.method}: ${routePath}"`, { contextMethod: 'factorizeRouting', offset: 1, printStacktrace: false });
            }
            if (canOverrideRoute(route) && foundRoute.methods[route.method]) {
                return;
            }
            return foundRoute.methods[route.method] = method;
        }
        return routing.push({
            path,
            regExp,
            methods: { [route.method]: method },
        });
    });
    return routing;
};
exports.factorizeRouting = factorizeRouting;
const factorizeRoutingWithDefaults = (routes, middlewares = []) => (0, exports.factorizeRouting)([...routes, http_router_effects_1.notFound$], middlewares);
exports.factorizeRoutingWithDefaults = factorizeRoutingWithDefaults;
