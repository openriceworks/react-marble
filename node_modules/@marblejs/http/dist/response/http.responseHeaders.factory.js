"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.factorizeHeaders = exports.provideContentTypeHeader = exports.provideContentLengthHeader = exports.DEFAULT_HEADERS = void 0;
const O = require("fp-ts/lib/Option");
const IO = require("fp-ts/lib/IO");
const function_1 = require("fp-ts/lib/function");
const utils_1 = require("@marblejs/core/dist/+internal/utils");
const contentType_util_1 = require("../+internal/contentType.util");
const header_util_1 = require("../+internal/header.util");
const http_config_1 = require("../http.config");
exports.DEFAULT_HEADERS = {
    'Content-Type': contentType_util_1.ContentType.APPLICATION_JSON,
    'X-Content-Type-Options': 'nosniff',
};
const config = (0, http_config_1.provideConfig)();
const provideContentLengthHeader = (response) => {
    if ((0, utils_1.isStream)(response.body))
        return {};
    const contentLength = (0, utils_1.isNullable)(response.body) ? 0 : Buffer.byteLength((0, utils_1.isString)(response.body) || Buffer.isBuffer(response.body)
        ? response.body
        : JSON.stringify(response.body));
    return {
        'Content-Length': contentLength,
    };
};
exports.provideContentLengthHeader = provideContentLengthHeader;
const provideContentTypeHeader = (response) => {
    const contentType = response.status < 400
        ? (0, contentType_util_1.getMimeType)(response.body, response.path)
        : exports.DEFAULT_HEADERS['Content-Type'];
    return {
        'Content-Type': contentType !== null && contentType !== void 0 ? contentType : exports.DEFAULT_HEADERS['Content-Type'],
    };
};
exports.provideContentTypeHeader = provideContentTypeHeader;
const factorizeHeaders = (response) => {
    const defaultContentTypeHeaders = (0, function_1.pipe)(O.fromNullable(response.headers), O.chain(contentType_util_1.getContentType), O.fold(() => (Object.assign(Object.assign({}, (0, exports.provideContentTypeHeader)(response)), (0, exports.provideContentLengthHeader)(response))), () => (0, function_1.pipe)(O.fromNullable(response.headers), O.chain(contentType_util_1.getContentLength), O.fold(() => (Object.assign({}, (0, exports.provideContentLengthHeader)(response))), (0, function_1.constant)({})))));
    const mergedHeaders = Object.assign(Object.assign(Object.assign({}, exports.DEFAULT_HEADERS), defaultContentTypeHeaders), response.headers);
    return (0, function_1.pipe)(config.useHttpHeadersNormalization, IO.map(shouldNormalize => shouldNormalize ? (0, header_util_1.normalizeHeaders)(mergedHeaders) : mergedHeaders));
};
exports.factorizeHeaders = factorizeHeaders;
