"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleResponse = exports.streamBody = exports.endRequest = exports.endRequestAndWriteBody = exports.writeHead = void 0;
const url = require("url");
const operators_1 = require("rxjs/operators");
const IO = require("fp-ts/lib/IO");
const T = require("fp-ts/lib/Task");
const function_1 = require("fp-ts/lib/function");
const core_1 = require("@marblejs/core");
const utils_1 = require("@marblejs/core/dist/+internal/utils");
const http_interface_1 = require("../http.interface");
const http_responseHeaders_factory_1 = require("./http.responseHeaders.factory");
const http_responseBody_factory_1 = require("./http.responseBody.factory");
const warnIfOutgoingConnectionEnded = (logger) => () => logger({
    tag: "http" /* HTTP */,
    level: core_1.LoggerLevel.WARN,
    type: 'Server',
    message: 'Attempted to send a response to an already finished connection',
});
const getResponseStatus = (effectResponse) => { var _a; return (_a = effectResponse.status) !== null && _a !== void 0 ? _a : http_interface_1.HttpStatus.OK; };
const getRequestUrl = (request) => { var _a; return (_a = url.parse(request.url).pathname) !== null && _a !== void 0 ? _a : ''; };
const writeHead = (status, headers) => (response) => () => { response.writeHead(status, headers); return headers; };
exports.writeHead = writeHead;
const endRequestAndWriteBody = (body) => (res) => () => new Promise(resolve => res.end(body, () => resolve(true)));
exports.endRequestAndWriteBody = endRequestAndWriteBody;
const endRequest = (res) => () => new Promise(resolve => res.end(undefined, () => resolve(true)));
exports.endRequest = endRequest;
const streamBody = (body) => (response) => () => (body.pipe(response), Promise.resolve(true));
exports.streamBody = streamBody;
/**
 * Send HTTP response
 *
 * @sig `ContextProvider -> HttpResponse -> HttpRequest -> HttpEffectResponse -> Observable`
 * @since 1.0.0
 */
const handleResponse = ask => {
    const logger = (0, core_1.useContext)(core_1.LoggerToken)(ask);
    return res => req => effectRes => {
        if (res.writableEnded)
            return (0, function_1.pipe)(warnIfOutgoingConnectionEnded(logger), utils_1.fromIO, (0, operators_1.mapTo)(false));
        const status = getResponseStatus(effectRes);
        const path = getRequestUrl(req);
        return (0, function_1.pipe)((0, http_responseHeaders_factory_1.factorizeHeaders)({ body: effectRes.body, headers: effectRes.headers, path, status }), IO.chain(headers => (0, exports.writeHead)(status, headers)(res)), IO.chain(headers => IO.of((0, http_responseBody_factory_1.factorizeBody)({ headers, body: effectRes.body }))), T.fromIO, T.chain(body => (0, utils_1.isStream)(body)
            ? (0, exports.streamBody)(body)(res)
            : (0, exports.endRequestAndWriteBody)(body)(res)), utils_1.fromTask);
    };
};
exports.handleResponse = handleResponse;
