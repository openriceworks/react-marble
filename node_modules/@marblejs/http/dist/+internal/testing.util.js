"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTestRoute = exports.createMockEffectContext = exports.createHttpResponse = exports.createHttpRequest = void 0;
const http = require("http");
const events_1 = require("events");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const core_1 = require("@marblejs/core");
const http_router_params_factory_1 = require("../router/http.router.params.factory");
const httpRequestBus_reader_1 = require("../server/internal-dependencies/httpRequestBus.reader");
const httpServerClient_reader_1 = require("../server/internal-dependencies/httpServerClient.reader");
const createHttpRequest = (data) => Object.assign({}, {
    url: '/',
    method: 'GET',
    headers: {},
    query: {},
    params: {},
    meta: {},
    response: (0, exports.createHttpResponse)(),
}, data);
exports.createHttpRequest = createHttpRequest;
const createHttpResponse = (data = {}) => new class extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.statusCode = data.statusCode;
        this.writeHead = jest.fn();
        this.setHeader = jest.fn();
        this.getHeader = jest.fn();
        this.end = jest.fn((_, cb) => cb());
        this.send = jest.fn(() => (0, rxjs_1.of)(true));
    }
};
exports.createHttpResponse = createHttpResponse;
const createMockEffectContext = () => {
    const dependencies = [
        (0, core_1.bindTo)(core_1.LoggerToken)(core_1.mockLogger),
        (0, core_1.bindTo)(httpRequestBus_reader_1.HttpRequestBusToken)(httpRequestBus_reader_1.HttpRequestBus),
        (0, core_1.bindTo)(httpServerClient_reader_1.HttpServerClientToken)((0, httpServerClient_reader_1.HttpServerClient)(http.createServer())),
    ];
    const context = (0, core_1.registerAll)(dependencies)((0, core_1.createContext)());
    const client = http.createServer();
    return (0, core_1.createEffectContext)({ ask: (0, core_1.lookup)(context), client });
};
exports.createMockEffectContext = createMockEffectContext;
const createTestRoute = (opts) => {
    var _a, _b;
    const method = (_a = opts === null || opts === void 0 ? void 0 : opts.method) !== null && _a !== void 0 ? _a : 'GET';
    const routeDelay = (_b = opts === null || opts === void 0 ? void 0 : opts.delay) !== null && _b !== void 0 ? _b : 0;
    const req = (0, exports.createHttpRequest)(({ url: `/delay_${routeDelay}`, method }));
    const path = (0, http_router_params_factory_1.factorizeRegExpWithParams)(`/delay_${routeDelay}`);
    const effect = req$ => {
        var _a;
        (_a = opts === null || opts === void 0 ? void 0 : opts.effectSpy) === null || _a === void 0 ? void 0 : _a.call(opts);
        return req$.pipe((0, operators_1.delay)(routeDelay), (0, operators_1.tap)(() => { if (opts === null || opts === void 0 ? void 0 : opts.throwError)
            throw new Error(); }), (0, operators_1.mapTo)({ body: `delay_${routeDelay}` }));
    };
    const item = {
        regExp: path.regExp,
        path: path.path,
        methods: { [method]: { effect, middlewares: [] } },
    };
    return { req, path, effect, item };
};
exports.createTestRoute = createTestRoute;
