"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServer = void 0;
const http = require("http");
const https = require("https");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const function_1 = require("fp-ts/lib/function");
const Array_1 = require("fp-ts/lib/Array");
const core_1 = require("@marblejs/core");
const utils_1 = require("@marblejs/core/dist/+internal/utils");
const http_config_1 = require("../http.config");
const http_effects_1 = require("../effects/http.effects");
const http_server_event_1 = require("./http.server.event");
// internal dependencies
const httpRequestMetadataStorage_reader_1 = require("./internal-dependencies/httpRequestMetadataStorage.reader");
const httpServerEventStream_reader_1 = require("./internal-dependencies/httpServerEventStream.reader");
const httpRequestBus_reader_1 = require("./internal-dependencies/httpRequestBus.reader");
const httpServerClient_reader_1 = require("./internal-dependencies/httpServerClient.reader");
const createServer = (config) => __awaiter(void 0, void 0, void 0, function* () {
    const { listener, event$, port, hostname, dependencies = [], options = {} } = config;
    const environmentConfig = (0, http_config_1.provideConfig)();
    const server = options.httpsOptions
        ? https.createServer(options.httpsOptions)
        : http.createServer();
    const boundHttpServerClient = (0, core_1.bindEagerlyTo)(httpServerClient_reader_1.HttpServerClientToken)((0, httpServerClient_reader_1.HttpServerClient)(server));
    const boundHttpServerEvent = (0, core_1.bindEagerlyTo)(httpServerEventStream_reader_1.HttpServerEventStreamToken)((0, httpServerEventStream_reader_1.HttpServerEventStream)({ server, hostname }));
    const boundHttpRequestBus = (0, core_1.bindEagerlyTo)(httpRequestBus_reader_1.HttpRequestBusToken)(httpRequestBus_reader_1.HttpRequestBus);
    const boundHttpRequestMetadataStorage = (0, core_1.bindTo)(httpRequestMetadataStorage_reader_1.HttpRequestMetadataStorageToken)(httpRequestMetadataStorage_reader_1.HttpRequestMetadataStorage);
    const context = yield (0, core_1.contextFactory)(boundHttpServerClient, boundHttpServerEvent, boundHttpRequestBus, ...(0, utils_1.insertIf)(environmentConfig.useHttpRequestMetadata())(boundHttpRequestMetadataStorage), ...(0, Array_1.filter)(utils_1.isNonNullable)(dependencies));
    (0, core_1.logContext)("http" /* HTTP */)(context);
    const ask = (0, core_1.lookup)(context);
    const ctx = (0, core_1.createEffectContext)({ ask, client: server });
    const httpListener = listener(context);
    const serverEvent$ = (0, core_1.useContext)(httpServerEventStream_reader_1.HttpServerEventStreamToken)(ask);
    (0, function_1.pipe)((0, rxjs_1.merge)(event$ ? event$(serverEvent$, ctx) : rxjs_1.EMPTY, (0, http_effects_1.listening$)(serverEvent$, ctx), (0, http_effects_1.error$)(serverEvent$, ctx), (0, http_effects_1.close$)(serverEvent$, ctx)), (0, operators_1.takeWhile)(e => !(0, http_server_event_1.isCloseEvent)(e), true)).subscribe();
    const listen = () => new Promise((resolve, reject) => {
        const runningServer = server.listen(port, hostname);
        // @TODO: bind Routing
        runningServer.on('request', httpListener);
        runningServer.on('close', runningServer.removeAllListeners);
        runningServer.on('error', reject);
        runningServer.on('listening', () => resolve(runningServer));
    });
    listen.context = context;
    return listen;
});
exports.createServer = createServer;
